Pseudo code for Reading AST F4


1 - Parent object Structure - 
  - "exported_functions" : [List of exported functions]
  - "identifiers" : Object
    - Indentifier Object Structure :
    {
      "contract_name" : string 
      "issuer_raw" : [] // can ignore
      "issuer_principal" : string
    }
  - "expressions" : [list of expressions]
    - Each element of the expressions array represents an expression and is a sub-array.
      - The order of Sub-array elements is as follow :
        - type of expression : 
          [0] "Declaration" : 
                - "data-var" //represents variable declaration e-g (define-data-var o1 (int 0))
                - "constant" //represents constant declaration e-g (define-constant c1 u0)
                - "map"   //does not have obtypes, instead has keytype and valtype
                - "trait" 
                - "def-ft"  //does not have objtypes, it may have "total_supply" or nothing.
                - "def-nft"
                - ... do we need anymore ?
                "Functions" : // do not contain objtype at parent. instead it contains "args:[]" and "body:[]"
                - "var-get" : // gets the value of an already defined variable by referring to "cid" and "identifier name" and "scope"
                - "read-only" // creates a function that does not modify values, but only reads values
                - "private" , "public"
          [1] "Object" // Expression Node
                {
                  "type" : string // The type of the expression,
                  "identifier" : string // The value/name of the expression,
                  "cid" : int // internal use to refer to nodes already declared in the system
                  "id" : int // if cids are consistent in the AST for same element being referred to, then we can ignore "id"
                  "scope" : local / global
                  "span" : Object // contains location information
                      {
                        "start_line": int
                        "start_column": int
                        "end_line": int
                        "end_column": int
                      }
                  "objtype": [list containing type information regarding the identifier]
                      [0] type : string // example "uint"
                          - [0] can be literal type e-g uint, int , string-ascii, string-utf8, bool, principal, buff, etc
                          - [0] can be "optional" which means the type is optional and requires special handling 
                          - [0] can be a funcion name, which means the following items are function params
                          - [0] can be operator, which means the following items are the operands.
                          - [0] can be "response" which means it will require special handling. Like, it will have two objTypes (sucess type, failure type)
                          - [0] can be "tuple" and requires special handling
                      [1] type identifer : string //example uint_128
                        - However, if the [0] anything other than a literal type then special handling is needed.
                      [2]  size of identifier

                      Example : "objtype" : ["uint", "uint_128", 128]
                      Example : "objtype" : ["optional","optional", object(objtype)]
                  "return_type": [objtype node for functions]
                  "args": [List of Expression nodes as arguments to the operation
                        ],
                  "body": [ Optional List of Expression nodes as part of sequence of expressions or function arguments
                        ],
                
                  
                  "keytype" : ONLY FOR MAPS --- follows objtype structure for type of "keys" of maps
                  "valtype" : ONLY FOR MAPS --- follows objtype structure for type of "values" of maps
                  "total_supply" : ONLY FOR FTs --- contains the total supply as unsigned int value.
                  
                  "type" : ONLY FOR Expression node --- defines a type of expression. 
                  "args" : ONLY FOR Expression node --- 
                           These will be the arguments passed to functions. There can be two types of arguments
                              - Arguments passed by value
                              - Declarative arguments that contain the initial values for ex let
                  "body" : ONLY FOR Expression node --- 
                           Function expresion sequence
                           Certain types of native functions like let or begin contain a sequence of expressions. 
                           This field will contain the sequence of Expression Nodes that are used in the native type
                  "return_type" : ONLY FOR Expression Node --- 
                           For functions defines the return type
                           For trait_functions this object must be present to define the functions return_type
                }

==> Special Handling for Optional Types:
if objtype[0] is "optional" that means objtype[3] would another objtype representing what type of optional value to expect.
then 
  if value node is an array 
  then
    if value[0] is "some"
    then 
      value[1] is the value or an expression that would result in objtype[3] type.
    else
      invalid value.
  else
    value will be "none" string.
  

==> Special Handling for Tuple Types:
objtype[0] = "tuple"
...[1] will be an object containing keys for members of tuples. each corresponding "value" is an objtype array 
...[2] will contain the number of keys to expect in the tuple.

==> List of types
function_declaration      --> Function declared
variable_declaration      --> Variable declaration
constant_declaration      --> Constant declaration
native_function           --> Functions specified in the link https://docs.stacks.co/clarity/function
user_function             --> Function created by the user
lit_uint                  --> “u0”
lit_ascii                 --> “somestring”
lit_bool                  --> “true”/”false”
function_arg              --> functions arguments
tuple_object              --> A tuple object expression
tuple_key                 --> Tuple key expression
let_variable_declaration  --> A variable declaration expression in let
conditional_expression    --> “If” expression
variable_name             --> variable used in an expression
optional_expression       --> “some”/”none”
response_expression       --> “ok”/”err”
trait_declaration         --> A trait is being declared
trait_function            --> A function definition that is part of a trait
trait_arg                 --> The arguments as part of a trait function

